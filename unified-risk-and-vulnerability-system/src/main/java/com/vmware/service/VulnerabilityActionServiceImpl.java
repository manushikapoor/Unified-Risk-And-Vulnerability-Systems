package com.vmware.service;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.vmware.constants.ApplicationConstants;
import com.vmware.dto.ActionRequestDTO;
import com.vmware.repository.OssVulnerabilitiesRepository;

@Service
public class VulnerabilityActionServiceImpl implements VulnerabilityActionService {

	private final Path root = Paths.get("uploads");
	
	@Autowired
	private OssVulnerabilitiesRepository ossVulnerabilitiesRepository;
	
	@Override
	public void markVulnerabilityAsFalsePositiveOrRemediation(
			Map<String, String> requestParams, MultipartFile file) throws Exception {
		// Check for unauthorized access
		if(
			ApplicationConstants.SECURITY_TEAM_ROLE.equals(requestParams.get("role").toString())
			&& (
				ApplicationConstants.FALSE_POSITIVE_ACTION.equals(requestParams.get("action"))
				|| ApplicationConstants.REMEDIATE_ACTION.equals(requestParams.get("action"))
			)
		) {
			throw new Exception("Security Team is unauthorized for this action");
		}
		// Check for action string
		String action = requestParams.get("action").toString();
		if(action == null || action.isBlank()) {
			throw new Exception("Action cannot be blank");
		}
		
		ObjectMapper mapper = new ObjectMapper();
		List<ActionRequestDTO> listOfIDs = mapper.readValue(requestParams.get("selected").toString(), new TypeReference<List<ActionRequestDTO>>(){});
		String filePath = null;
		try {
			if(file != null) {
				filePath = this.uploadToLocalFileSystem(file);
			}
		} catch(Exception e) {
			throw e;
		}
		
		// Update table depending on role
		for(ActionRequestDTO dto: listOfIDs) {
			int ossSecurityScanId = dto.getOssSecurityScanId();
			String vulnId = dto.getVulnId();
			String approvalStatus = null;
			String vulnerabilityStatus = null;
			if(ApplicationConstants.SECURITY_TEAM_ROLE.equals(requestParams.get("role").toString())) {
				approvalStatus = 
						ApplicationConstants.APPROVE_ACTION.equals(action) 
						? ApplicationConstants.STATUS_APPROVED 
						: ApplicationConstants.STATUS_REJECTED;
				vulnerabilityStatus = 
						approvalStatus.equals(ApplicationConstants.STATUS_APPROVED)
						? ApplicationConstants.VULNERABILITY_CLOSED
						: ApplicationConstants.VULNERABILITY_OPEN;
				ossVulnerabilitiesRepository.updateApprovalStatus(ossSecurityScanId, vulnId, vulnerabilityStatus, approvalStatus);
			} else {
				approvalStatus = ApplicationConstants.STATUS_IN_PROGRESS;
				vulnerabilityStatus = action;
				String comments = requestParams.get("comments").toString();
				if(file != null && filePath != null && !filePath.isBlank()) {
					ossVulnerabilitiesRepository.updateStatusWithApprovalInProgress(
							ossSecurityScanId, vulnId, vulnerabilityStatus, approvalStatus, comments, filePath);
				} else {
					ossVulnerabilitiesRepository.updateStatusWithApprovalInProgress(
							ossSecurityScanId, vulnId, vulnerabilityStatus, approvalStatus, comments);
				}
			}
		}
	}
	
	private String write(MultipartFile file, Path dir) throws IOException {
		if(!Files.exists(dir)) {
    		Files.createDirectories(dir);
    	}
		Path filepath = Paths.get(dir.toString(), file.getOriginalFilename());
	    try (OutputStream os = Files.newOutputStream(filepath)) {
	        os.write(file.getBytes());
	    } catch(IOException e) {
	    	throw e;
	    }
	    return filepath.toString();
	}
	
	private String uploadToLocalFileSystem(MultipartFile file) throws IOException {
		String fileName = StringUtils.cleanPath(file.getOriginalFilename());
		Path path = Paths.get(fileName);
		try {
			Files.copy(file.getInputStream(), path, StandardCopyOption.REPLACE_EXISTING);
		} catch (IOException e) {
			e.printStackTrace();
		}
		String fileDownloadUri = ServletUriComponentsBuilder.fromCurrentContextPath()
				.path("/files/download/")
				.path(fileName)
				.toUriString();
		return fileDownloadUri;
	}
	
}
